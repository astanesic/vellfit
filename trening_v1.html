<!doctype html>
<html lang="hr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Intervalni Trener (stanice)</title>
  <style>
    :root{
      --bg:#0b1020; --panel:#121936; --muted:#9aa4c7; --accent:#4cc9f0; --good:#7bd88f; --warn:#ffd166; --bad:#ef476f;
      --glow:#3a86ff; --shadow:0 8px 25px rgba(0,0,0,.35);
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Inter,sans-serif; color:#eef2ff; background:linear-gradient(135deg,var(--bg) 0%, #0f1530 100%); min-height:100vh;}
    .wrap{max-width:1100px; margin:0 auto; padding:16px;}
    h1{font-size:24px; margin:0 0 20px 0; font-weight:800; letter-spacing:.3px; text-shadow:0 2px 10px rgba(58,134,255,.3)}
    .grid{display:grid; grid-template-columns:1.1fr .9fr; gap:20px}
    .card{background:var(--panel); border:1px solid rgba(255,255,255,.08); border-radius:20px; padding:20px; box-shadow:var(--shadow); backdrop-filter:blur(10px)}
    .card h2{font-size:16px; color:var(--muted); font-weight:700; margin:0 0 12px 0; text-transform:uppercase; letter-spacing:.1em}
    label{display:block; font-size:14px; color:var(--muted); margin:10px 0 8px; font-weight:500}
    textarea,input{width:100%; border-radius:12px; border:1px solid rgba(255,255,255,.1); background:rgba(15,21,48,.8); color:#e7ecff; padding:12px; font-size:15px; transition:.2s all ease;}
    textarea{min-height:120px; resize:vertical;}
    input[type=number]{max-width:130px}
    .row{display:flex; gap:12px; align-items:center; flex-wrap:wrap}
    .btn{appearance:none; border:none; border-radius:14px; padding:12px 18px; cursor:pointer; font-weight:700; letter-spacing:.3px; background:#1a2248; color:#e9f1ff; transition:.15s all ease; text-shadow:0 1px 2px rgba(0,0,0,.2)}
    .btn:hover{transform:translateY(-2px); box-shadow:0 6px 20px rgba(0,0,0,.3)}
    .btn.primary{background:linear-gradient(135deg,#3a86ff,#8338ec); box-shadow:0 4px 15px rgba(58,134,255,.3)}
    .btn.green{background:linear-gradient(135deg,#06d6a0,#118ab2); box-shadow:0 4px 15px rgba(6,214,160,.3)}
    .btn.red{background:linear-gradient(135deg,#ef476f,#f3722c); box-shadow:0 4px 15px rgba(239,71,111,.3)}
    .btn.ghost{background:transparent; border:2px dashed rgba(255,255,255,.3); box-shadow:none}
    .btn.ghost:hover{border-color:var(--accent); background:rgba(76,201,240,.1)}
    .muted{color:var(--muted)}

    .timer{display:grid; grid-template-columns:1fr; gap:15px; text-align:center}
    .phase{font-size:15px; color:#c7d0f0; letter-spacing:.2em; text-transform:uppercase; font-weight:600}
    .time{font-size:76px; font-weight:900; line-height:1; text-shadow:0 4px 20px rgba(0,0,0,.5)}
    .time.small{font-size:48px}
    .rounds{font-size:16px; color:#cfe3ff; font-weight:500}
    progress{width:100%; height:20px; -webkit-appearance:none; appearance:none; border-radius:12px; overflow:hidden; box-shadow:inset 0 2px 8px rgba(0,0,0,.3)}
    progress::-webkit-progress-bar{background:rgba(11,17,48,.8); border-radius:12px}
    progress::-webkit-progress-value{background:linear-gradient(90deg,var(--accent),#7bd88f); border-radius:12px; box-shadow:0 0 10px rgba(76,201,240,.4)}

    table{width:100%; border-collapse:separate; border-spacing:0 10px}
    th,td{text-align:left; padding:15px 18px; font-size:18px; font-weight:500}
    thead th{color:var(--muted); font-size:14px; text-transform:uppercase; letter-spacing:.1em; font-weight:700}
    tbody tr{background:rgba(14,23,54,.6); border:1px solid rgba(255,255,255,.08); backdrop-filter:blur(5px)}
    tbody tr td:first-child{border-radius:12px 0 0 12px}
    tbody tr td:last-child{border-radius:0 12px 12px 0}

    .badger{display:inline-block; padding:6px 14px; border-radius:20px; font-size:14px; font-weight:700; text-shadow:0 1px 3px rgba(0,0,0,.3)}
    .work{background:linear-gradient(135deg,#24365a,#4a5fa8); color:#a9d6ff; box-shadow:0 3px 10px rgba(36,54,90,.4)}
    .rest{background:linear-gradient(135deg,#2a2048,#5a4088); color:#f7d6ff; box-shadow:0 3px 10px rgba(42,32,72,.4)}
    .round-rest{background:linear-gradient(135deg,#4a2060,#7a4088); color:#ffddff; box-shadow:0 3px 10px rgba(74,32,96,.4)}

    .warn{color:var(--warn)}
    .note{font-size:14px; color:#c9d7ff; font-weight:400}

    .flex-between{display:flex; justify-content:space-between; align-items:center}
    .stack{display:flex; flex-direction:column; gap:8px}
    .controls{display:flex; gap:10px; flex-wrap:wrap}

    .footer{margin-top:16px; color:var(--muted); font-size:13px}

    /* Fullscreen styles */
    .fullscreen-mode { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: linear-gradient(135deg,var(--bg) 0%, #0f1530 100%); z-index: 9999; display: flex; flex-direction: column; padding: 25px; }
    .fullscreen-mode .fullscreen-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 25px; }
    .fullscreen-mode .header-controls { display: flex; gap: 15px; align-items: center; }
    .fullscreen-mode .exit-btn { background: rgba(239,71,111,.2); border: 2px solid rgba(239,71,111,.4); color: #ff6b94; padding: 12px 18px; border-radius: 12px; cursor: pointer; font-size: 16px; font-weight: 600; transition: .2s all ease; }
    .fullscreen-mode .exit-btn:hover { background: rgba(239,71,111,.3); transform: translateY(-1px); }
    .fullscreen-mode .fullscreen-content { flex: 1; display: grid; grid-template-columns: 2fr 3fr; gap: 25px; align-items: stretch; }
    .fullscreen-mode .timer { background: var(--panel); border: 1px solid rgba(255,255,255,.1); border-radius: 25px; padding: 50px; text-align: center; box-shadow: var(--shadow); backdrop-filter: blur(15px); }
    .fullscreen-mode .time { font-size: 140px; text-shadow: 0 6px 30px rgba(0,0,0,.6); }
    .fullscreen-mode .time.small { font-size: 90px; }
    .fullscreen-mode progress { height: 25px; border-radius: 15px; }
    .fullscreen-mode .mapping-card { background: var(--panel); border: 1px solid rgba(255,255,255,.1); border-radius: 25px; padding: 40px; box-shadow: var(--shadow); backdrop-filter: blur(15px); }
    .fullscreen-mode .mapping-card h2 { font-size: 22px; margin-bottom: 10px; font-weight: 800; }
    .fullscreen-mode .fullscreen-meta { font-size: 16px; color: #cfe3ff; margin-bottom: 15px; }

    @media (max-width:860px){
      .grid{grid-template-columns:1fr}
      .time{font-size:60px}
      .fullscreen-mode .fullscreen-content { grid-template-columns: 1fr; gap: 20px; }
      .fullscreen-mode .time { font-size: 90px; }
      .fullscreen-mode .time.small { font-size: 70px; }
    }
  </style>
</head>
<body>
  <div class="wrap" id="normalView">
    <h1>Intervalni Trener (stanice)</h1>
    <div class="grid">
      <div class="card">
        <h2>Postavke</h2>
        <label>Vježbe (jedna po liniji ili odvojene zarezom)</label>
        <textarea id="exercises">1. guma
2. trax
3. puzanje
4. trbušnjaci</textarea>
        <label>Osobe (jedna po liniji ili odvojene zarezom)</label>
        <textarea id="people">Ana
Buba
Biba</textarea>
        <div class="row">
          <div class="stack">
            <label>Rad (sek)</label>
            <input id="workSec" type="number" min="5" step="5" value="40" />
          </div>
          <div class="stack">
            <label>Odmor (sek)</label>
            <input id="restSec" type="number" min="0" step="5" value="30" />
          </div>
          <div class="stack">
            <label>Krugovi</label>
            <input id="rounds" type="number" min="1" step="1" value="3" />
          </div>
          <div class="stack">
            <label>Odmor između krugova (sek)</label>
            <input id="roundRestSec" type="number" min="0" step="5" value="60" />
          </div>
          <div class="stack" style="min-width:150px">
            <label>Glasnoća</label>
            <input id="vol" type="range" min="0" max="100" value="80" />
          </div>
        </div>
        <div class="row" style="margin-top:12px">
          <button class="btn ghost" id="fullscreen">⛶ Cijeli ekran</button>
          <label style="display:flex; gap:8px; align-items:center; margin-left:auto;">
            <input type="checkbox" id="beeps" checked /> Zvukovi
          </label>
        </div>
        <div class="note" style="margin-top:12px">Ukupno planirano vrijeme: <span id="totalPlan">—:—</span>
          <span id="mismatch" class="warn" style="display:none"> • Napomena: broj osoba i vježbi nije isti — rotacija će ponavljati vježbe.</span>
        </div>
        <div class="controls" style="margin-top:15px">
          <button class="btn primary" id="start">▶️ Start</button>
          <button class="btn" id="pause">⏸ Pauza</button>
          <button class="btn red" id="reset">⟲ Reset</button>
          <button class="btn" id="skip">⏭️ Preskoči fazu</button>
        </div>
      </div>

      <div class="card">
        <h2>Status</h2>
        <div class="timer" id="timerSection">
          <div class="phase"><span id="phaseBadge" class="badger work">Rad</span></div>
          <div class="time" id="timeLeft">00:40</div>
          <progress id="bar" max="1" value="0"></progress>
          <div class="flex-between">
            <div class="rounds">Krug: <strong id="roundInfo">1 / 3</strong></div>
            <div class="rounds">Preostalo ukupno: <strong id="totalRemain">—:—</strong></div>
          </div>
        </div>
      </div>
    </div>

    <div class="card" style="margin-top:20px" id="mappingSection">
      <h2><span id="mappingTitle">Tko radi koju vježbu (sada)</span></h2>
      <table>
        <thead>
          <tr><th>Osoba</th><th>Vježba</th></tr>
        </thead>
        <tbody id="mapping"></tbody>
      </table>
      <div class="footer">Savjet: okreni telefon vodoravno i uključi <em>Cijeli ekran</em> za pregledniji prikaz.</div>
    </div>

    <div class="card" style="margin-top:20px">
      <h2>Upute</h2>
      <ul>
        <li>Unesi vježbe i osobe. Broj ne mora biti jednak (ako nije, vježbe će se ponavljati).</li>
        <li>Postavi trajanja, broj krugova i odmor između krugova.</li>
        <li>Klikni <strong>Start</strong> (prvi klik aktivira zvuk u pregledniku). Zadnjih 5 sekundi svake faze čuje se "pip", a na kraju faze drugačiji zvuk.</li>
        <li>Rotacija se događa nakon odmora. Nakon posljednje vježbe zadnjeg kruga nema završnog odmora.</li>
      </ul>
    </div>

    <!-- Preseti -->
    <div class="card" style="margin-top:20px" id="presets">
      <h2>Preseti</h2>
      <div class="row" style="margin-bottom:10px">
        <input type="text" id="presetName" placeholder="Naziv preseta" />
        <button class="btn green" id="savePresetBtn">💾 Spremi</button>
      </div>
      <div id="presetList" class="stack"></div>
    </div>
  </div>

  <!-- Fullscreen View -->
  <div class="fullscreen-mode" id="fullscreenView" style="display: none;">
    <div class="fullscreen-header">
      <div class="header-controls">
        <button class="btn primary control-btn" id="fullscreenStart">▶️ Start</button>
        <button class="btn control-btn" id="fullscreenPause">⏸ Pauza</button>
        <button class="btn red control-btn" id="fullscreenReset">⟲ Reset</button>
        <button class="btn control-btn" id="fullscreenSkip">⏭️ Preskoči</button>
      </div>
      <button class="exit-btn" id="exitFullscreen">✕ Izađi</button>
    </div>
    
    <div class="fullscreen-content">
      <div class="timer" id="fullscreenTimer">
        <div class="phase"><span id="fullscreenPhaseBadge" class="badger work">Rad</span></div>
        <div class="time" id="fullscreenTimeLeft">00:40</div>
        <progress id="fullscreenBar" max="1" value="0"></progress>
        <div class="flex-between">
          <div class="rounds">Krug: <strong id="fullscreenRoundInfo">1 / 3</strong></div>
          <div class="rounds">Preostalo ukupno: <strong id="fullscreenTotalRemain">—:—</strong></div>
        </div>
      </div>
      
      <div class="mapping-card">
        <h2><span id="fullscreenMappingTitle">Tko radi koju vježbu (sada)</span></h2>
        <div class="fullscreen-meta" id="fullscreenRoundMeta">Vrijeme do kraja kruga: —:— • Korak u krugu: —/— • Preostalo vježbi u ovom krugu: —</div>
        <table>
          <thead>
            <tr><th>Osoba</th><th>Vježba</th><th>Preostalo vježbi</th></tr>
          </thead>
          <tbody id="fullscreenMapping"></tbody>
        </table>
      </div>
    </div>
  </div>

  <script>
    // ===== Helpers =====
    const $ = sel => document.querySelector(sel);
    const exercisesEl = $('#exercises');
    const peopleEl = $('#people');
    const workSecEl = $('#workSec');
    const restSecEl = $('#restSec');
    const roundsEl = $('#rounds');
    const roundRestSecEl = $('#roundRestSec');
    const volEl = $('#vol');
    const barEl = $('#bar');
    const timeLeftEl = $('#timeLeft');
    const roundInfoEl = $('#roundInfo');
    const totalPlanEl = $('#totalPlan');
    const totalRemainEl = $('#totalRemain');
    const mappingEl = $('#mapping');
    const phaseBadge = $('#phaseBadge');
    const mismatch = $('#mismatch');
    const mappingTitle = $('#mappingTitle');

    // Fullscreen elements
    const fullscreenView = $('#fullscreenView');
    const normalView = $('#normalView');
    const fullscreenBar = $('#fullscreenBar');
    const fullscreenTimeLeft = $('#fullscreenTimeLeft');
    const fullscreenRoundInfo = $('#fullscreenRoundInfo');
    const fullscreenTotalRemain = $('#fullscreenTotalRemain');
    const fullscreenMapping = $('#fullscreenMapping');
    const fullscreenPhaseBadge = $('#fullscreenPhaseBadge');
    const fullscreenMappingTitle = $('#fullscreenMappingTitle');
    const fullscreenRoundMeta = $('#fullscreenRoundMeta');

    const startBtn = $('#start');
    const pauseBtn = $('#pause');
    const resetBtn = $('#reset');
    const skipBtn = $('#skip');
    const fullscreenBtn = $('#fullscreen');
    const exitFullscreenBtn = $('#exitFullscreen');
    const beepsChk = $('#beeps');

    // Fullscreen controls
    const fullscreenStartBtn = $('#fullscreenStart');
    const fullscreenPauseBtn = $('#fullscreenPause');
    const fullscreenResetBtn = $('#fullscreenReset');
    const fullscreenSkipBtn = $('#fullscreenSkip');

    let isFullscreenMode = false;

    function linesToList(txt){
      return txt.split(/\n|,/).map(s=>s.replace(/^\\s*\\d+\\.?\\s*/, '').trim()).filter(Boolean);
    }
    function pad(n){return String(n).padStart(2,'0')}
    function fmtTime(s){s=Math.max(0, Math.ceil(s)); return `${pad(Math.floor(s/60))}:${pad(s%60)}`}

    // ===== State =====
    let state = {
      exercises: [],
      people: [],
      workSec: 40,
      restSec: 30,
      roundRestSec: 60,
      rounds: 3,
      totalWorkIntervals: 0,
      totalPhases: 0,
      totalPlannedSec: 0,
      started: false,
      paused: false,
      phaseIndex: 0,
      phaseStartMs: 0,
      phaseDurSec: 0,
      targetEndMs: 0,
      raf: null,
      beepedForSec: new Set(),
      wakeLock: null,
      audioCtx: null,
      gainNode: null,
      presets: []
    };

    // Wake lock
    async function requestWakeLock() { if ('wakeLock' in navigator && !state.wakeLock) { try { state.wakeLock = await navigator.wakeLock.request('screen'); state.wakeLock.addEventListener('release', () => { state.wakeLock = null; }); } catch(e){} } }
    function releaseWakeLock() { if (state.wakeLock) { state.wakeLock.release(); state.wakeLock = null; } }

    function computeTotals(){
      const ex = state.exercises.length;
      const N = state.rounds * Math.max(1, ex);
      state.totalWorkIntervals = N;
      const exercisesPerRound = Math.max(1, ex);
      const regularRestsPerRound = Math.max(0, exercisesPerRound - 1);
      const roundRests = Math.max(0, state.rounds - 1);
      const workPhases = N;
      const regularRestPhases = state.rounds * regularRestsPerRound;
      const roundRestPhases = roundRests;
      state.totalPhases = workPhases + regularRestPhases + roundRestPhases;
      const totalWorkTime = N * state.workSec;
      const totalRegularRestTime = regularRestPhases * state.restSec;
      const totalRoundRestTime = roundRests * state.roundRestSec;
      state.totalPlannedSec = totalWorkTime + totalRegularRestTime + totalRoundRestTime;
      totalPlanEl.textContent = fmtTime(state.totalPlannedSec);
      mismatch.style.display = state.people.length && state.exercises.length && state.people.length !== state.exercises.length ? 'inline' : 'none';
    }

    function readInputs(){
      state.exercises = linesToList(exercisesEl.value);
      state.people = linesToList(peopleEl.value);
      state.workSec = Math.max(1, parseInt(workSecEl.value||40,10));
      state.restSec = Math.max(0, parseInt(restSecEl.value||0,10));
      state.roundRestSec = Math.max(0, parseInt(roundRestSecEl.value||60,10));
      state.rounds = Math.max(1, parseInt(roundsEl.value||1,10));
      computeTotals();
      updateStaticUI();
      save();
    }

    function updateStaticUI(){
      const [rNow, rTot] = getRoundInfo();
      roundInfoEl.textContent = `${rNow} / ${rTot}`;
      fullscreenRoundInfo.textContent = `${rNow} / ${rTot}`;
      const timeText = fmtTime(currentPhaseRemaining());
      timeLeftEl.textContent = timeText;
      fullscreenTimeLeft.textContent = timeText;
      barEl.value = 0;
      fullscreenBar.value = 0;
      renderMapping();
      updatePhaseBadge();
      updateTotalRemaining();
      updateRoundExtras();
    }

    // Round helpers
    function exPerRound(){ return Math.max(1, state.exercises.length); }
    function perRoundNoRest(){ return exPerRound()*2 - 1; } // work/rest alternation, no round-rest

    function getRoundInfo(){
      let round = 1;
      let idx = 0;
      const per = perRoundNoRest();
      while (round <= state.rounds){
        const len = per + (round < state.rounds ? 1 : 0); // include round-rest after round except last
        if (state.phaseIndex < idx + len) break;
        idx += len; round++;
      }
      return [Math.min(round, state.rounds), state.rounds];
    }

    function getRoundStart(round){
      let start = 0;
      const per = perRoundNoRest();
      for(let r=1; r<round; r++){ start += per + (r < state.rounds ? 1 : 0); }
      return start;
    }

    function phaseTypeAt(phaseIdx){
      let round = 1, start = 0;
      const per = perRoundNoRest();
      while (round <= state.rounds){
        const len = per + (round < state.rounds ? 1 : 0);
        const end = start + len - 1;
        if (phaseIdx <= end){
          const idxInRound = phaseIdx - start;
          if (idxInRound < per) return idxInRound % 2 === 0 ? 'work' : 'rest';
          return 'round-rest';
        }
        start += len; round++;
      }
      return 'work';
    }

    function getRoundAndIndex(){
      const [rNow] = getRoundInfo();
      const start = getRoundStart(rNow);
      const per = perRoundNoRest();
      const idxInRoundFull = state.phaseIndex - start;
      const isRoundRest = idxInRoundFull >= per;
      if (isRoundRest){
        return { round:rNow, isRoundRest:true, idxInRound:null, inType:'round-rest' };
      }else{
        const idxInRound = idxInRoundFull;
        const inType = idxInRound % 2 === 0 ? 'work' : 'rest';
        return { round:rNow, isRoundRest:false, idxInRound, inType };
      }
    }

    function currentPhaseRemaining(){
      if(!state.started) {
        const t = phaseTypeAt(state.phaseIndex);
        if (t === 'work') return state.workSec;
        if (t === 'rest') return state.restSec;
        if (t === 'round-rest') return state.roundRestSec;
      }
      return Math.max(0, (state.targetEndMs - performance.now())/1000);
    }

    function timeRemainingInCurrentRound(){
      const ctx = getRoundAndIndex();
      if (ctx.isRoundRest) return 0;
      let remain = currentPhaseRemaining();
      const per = perRoundNoRest();
      for(let i = ctx.idxInRound + 1; i < per; i++){
        const t = i % 2 === 0 ? 'work' : 'rest';
        if (t === 'work') remain += state.workSec;
        else remain += state.restSec;
      }
      return remain;
    }

  function remainingExercisesPerPerson(){
    const ctx = getRoundAndIndex();
    if (ctx.isRoundRest) return 0;

    const total = exPerRound();
    const idx = ctx.idxInRound; // 0-based inside round (work/rest only)
    const doneBefore = Math.floor(idx / 2); // broj dovršenih WORK prije trenutne faze

    if (ctx.inType === 'work') {
      // trenutno radimo novu vježbu → nakon nje ostaje total - (doneBefore + 1)
      return Math.max(0, total - (doneBefore + 1));
    }

    // ako smo u REST fazi, upravo smo završili zadnju vježbu → isto kao gore
    return Math.max(0, total - (doneBefore + 1));
}

    function updatePhaseBadge(){
      const t = phaseTypeAt(state.phaseIndex);
      let phaseText, className, titleText;
      if (t === 'work') { phaseText='Rad'; className='badger work'; titleText='Tko radi koju vježbu (sada)'; }
      else if (t === 'rest') { phaseText='Odmor'; className='badger rest'; titleText='Sljedeće (nakon odmora)'; }
      else { phaseText='Odmor između krugova'; className='badger round-rest'; titleText='Sljedeći krug'; }
      phaseBadge.textContent = phaseText; phaseBadge.className = className;
      fullscreenPhaseBadge.textContent = phaseText; fullscreenPhaseBadge.className = className;
      mappingTitle.textContent = titleText; fullscreenMappingTitle.textContent = titleText;
      const isWork = t==='work';
      timeLeftEl.classList.toggle('small', !isWork);
      fullscreenTimeLeft.classList.toggle('small', !isWork);
      const remaining = currentPhaseRemaining();
      const showWarning = remaining <= 5 && remaining > 0 && state.started && !state.paused;
      timeLeftEl.classList.toggle('warning', showWarning);
      fullscreenTimeLeft.classList.toggle('warning', showWarning);
    }

    function renderMapping(){
      const people = state.people.length ? state.people : ['Osoba 1','Osoba 2','Osoba 3'];
      const ex = state.exercises.length ? state.exercises : ['Vježba 1','Vježba 2','Vježba 3'];
      const exLen = ex.length;

      // which work interval is displayed (current if work; next if rest/round-rest)
      let workIdxShown = 0;
      for (let i=0;i<=state.phaseIndex;i++){ if (phaseTypeAt(i)==='work') workIdxShown++; }
      workIdxShown--;
      const t = phaseTypeAt(state.phaseIndex);
      if (t !== 'work' && workIdxShown < state.totalWorkIntervals - 1) workIdxShown++;

      const rows = people.map((p, j) => {
        const exName = ex[(j + workIdxShown) % exLen];
        return `<tr><td>${escapeHtml(p)}</td><td>${escapeHtml(exName)}</td></tr>`;
      }).join('');

      mappingEl.innerHTML = rows;
      // fullscreen with per-person remaining count (same number for sve, ali prikaz po retku)
      const remainingCount = remainingExercisesPerPerson();
      const rowsFS = people.map((p, j) => {
        const exName = ex[(j + workIdxShown) % exLen];
        return `<tr><td>${escapeHtml(p)}</td><td>${escapeHtml(exName)}</td><td>${remainingCount}</td></tr>`;
      }).join('');
      fullscreenMapping.innerHTML = rowsFS;
    }

    function updateRoundExtras(){
      const timeRound = timeRemainingInCurrentRound();
      const ctx = getRoundAndIndex();
      const totalWorks = exPerRound();

      // step number within the round:
      // - during WORK: current step is doneBefore + 1
      // - during REST: the just-finished WORK also counts, so step = doneBefore + 1
      // - during ROUND-REST: all works are done
      let stepNum;
      if (ctx.isRoundRest) {
        stepNum = totalWorks;
      } else {
        const doneBefore = Math.floor(ctx.idxInRound / 2);
        stepNum = doneBefore + (ctx.inType === 'work' ? 1 : 1);
      }

      const remPer = remainingExercisesPerPerson();

      fullscreenRoundMeta.textContent = `Vrijeme do kraja kruga: ${fmtTime(timeRound)} • Korak u krugu: ${stepNum}/${totalWorks} • Preostalo vježbi u ovom krugu: ${remPer}`;
    }

    function escapeHtml(s){return s.replace(/[&<>\"']/g, c=>({"&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#39;"}[c]))}

    function setPhase(idx){
      state.phaseIndex = idx;
      const t = phaseTypeAt(idx);
      state.phaseDurSec = (t==='work') ? state.workSec : (t==='rest' ? state.restSec : state.roundRestSec);
      state.phaseStartMs = performance.now();
      state.targetEndMs = state.phaseStartMs + state.phaseDurSec * 1000;
      state.beepedForSec.clear();
      updatePhaseBadge();
      renderMapping();
      const [rNow, rTot] = getRoundInfo();
      roundInfoEl.textContent = `${rNow} / ${rTot}`;
      fullscreenRoundInfo.textContent = `${rNow} / ${rTot}`;
      updateRoundExtras();
      if(state.phaseDurSec === 0){ nextPhase(); }
    }

    function nextPhase(){
      if(state.phaseIndex >= state.totalPhases - 1){ finishWorkout(); return; }
      setPhase(state.phaseIndex + 1);
    }

    function start(){
      if(state.started && !state.paused) return;
      state.started = true; state.paused = false;
      requestWakeLock();
      if(!state.audioCtx){
        try{
          state.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
          state.gainNode = state.audioCtx.createGain();
          state.gainNode.gain.value = volEl.value/100 * 0.8;
          state.gainNode.connect(state.audioCtx.destination);
        }catch(e){}
      } else if (state.audioCtx.state === 'suspended'){
        state.audioCtx.resume();
      }
      tick();
    }

    function pause(){
      if(!state.started || state.paused) return;
      state.paused = true;
      cancelAnimationFrame(state.raf);
      state.phaseDurSec = currentPhaseRemaining();
    }

    function resume(){
      if(!state.paused) return;
      state.paused = false;
      state.phaseStartMs = performance.now();
      state.targetEndMs = state.phaseStartMs + state.phaseDurSec * 1000;
      state.beepedForSec.clear();
      tick();
    }

    function reset(){
      cancelAnimationFrame(state.raf);
      state.started = false; state.paused = false;
      state.phaseIndex = 0; state.beepedForSec.clear();
      releaseWakeLock();
      setPhase(0);
      barEl.value = 0; fullscreenBar.value = 0;
      const timeText = fmtTime(state.phaseDurSec);
      timeLeftEl.textContent = timeText; fullscreenTimeLeft.textContent = timeText;
      updateTotalRemaining(); updateRoundExtras();
      timeLeftEl.classList.remove('warning'); fullscreenTimeLeft.classList.remove('warning');
    }

    function finishWorkout(){
      cancelAnimationFrame(state.raf);
      chimeEndLong();
      state.started = false; state.paused = false;
      releaseWakeLock();
      barEl.value = 1; fullscreenBar.value = 1;
      timeLeftEl.textContent = 'GOTOVO'; fullscreenTimeLeft.textContent = 'GOTOVO';
      timeLeftEl.classList.remove('warning'); fullscreenTimeLeft.classList.remove('warning');
      updateRoundExtras();
    }

    function updateTotalRemaining(){
      let remain = currentPhaseRemaining();
      for(let i = state.phaseIndex + 1; i < state.totalPhases; i++){
        const t = phaseTypeAt(i);
        remain += (t==='work') ? state.workSec : (t==='rest' ? state.restSec : state.roundRestSec);
      }
      const remainText = fmtTime(remain);
      totalRemainEl.textContent = remainText; fullscreenTotalRemain.textContent = remainText;
    }

    function tick(){
      const now = performance.now();
      const elapsed = (now - state.phaseStartMs) / 1000;
      const dur = state.phaseDurSec;
      const remain = Math.max(0, dur - elapsed);
      const timeText = fmtTime(remain);
      timeLeftEl.textContent = timeText; fullscreenTimeLeft.textContent = timeText;
      const progress = dur ? Math.min(1, (elapsed / dur)) : 1;
      barEl.value = progress; fullscreenBar.value = progress;
      doBeeps(remain);
      updatePhaseBadge(); updateTotalRemaining(); updateRoundExtras();
      if(remain <= 0){ chimeEnd(); nextPhase(); }
      if(!state.paused && state.started){ state.raf = requestAnimationFrame(tick); }
    }

    // ===== Audio =====
    function playTone(freq=800, seconds=0.15, volume=0.6){
      if(!beepsChk.checked) return;
      try{
        const ctx = state.audioCtx; if(!ctx) return;
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        const masterVolume = (volEl.value/100) * volume;
        gain.gain.value = masterVolume;
        osc.type = 'sine'; osc.frequency.value = freq;
        osc.connect(gain); gain.connect(state.gainNode || ctx.destination);
        const t = ctx.currentTime;
        gain.gain.setValueAtTime(0, t);
        gain.gain.linearRampToValueAtTime(masterVolume, t+0.03);
        gain.gain.exponentialRampToValueAtTime(1e-3, t+seconds);
        osc.start(t); osc.stop(t + seconds + 0.05);
      }catch(e){}
    }

    function doBeeps(remain){
      const sec = Math.ceil(remain);
      if(sec <= 5 && sec > 0){
        if(!state.beepedForSec.has(sec)){
          const freq = sec === 1 ? 900 : 760;
          const volume = sec === 1 ? 0.8 : 0.7;
          playTone(freq, 0.15, volume);
          state.beepedForSec.add(sec);
        }
      }
    }

    function chimeEnd(){ setTimeout(()=>playTone(880, 0.25, 0.8), 0); setTimeout(()=>playTone(660, 0.25, 0.8), 180); setTimeout(()=>playTone(1100, 0.3, 0.9), 380); }
    function chimeEndLong(){ setTimeout(()=>playTone(660, 0.4, 0.9), 0); setTimeout(()=>playTone(880, 0.5, 1.0), 450); setTimeout(()=>playTone(1320, 0.6, 1.0), 1000); setTimeout(()=>playTone(1760, 0.8, 1.0), 1700); }

    // ===== Fullscreen Management =====
    function enterFullscreenMode() {
      isFullscreenMode = true;
      normalView.style.display = 'none';
      fullscreenView.style.display = 'flex';
      if (document.documentElement.requestFullscreen) {
        document.documentElement.requestFullscreen().catch(()=>{});
      }
    }
    function exitFullscreenMode() {
      isFullscreenMode = false;
      fullscreenView.style.display = 'none';
      normalView.style.display = 'block';
      if (document.fullscreenElement) {
        document.exitFullscreen().catch(()=>{});
      }
    }

    // ===== Controls =====
    function handleStart() { if(!state.started) { setPhase(0); } if(state.paused) { resume(); } else { start(); } }
    function handlePause() { state.paused ? resume() : pause(); }
    function handleReset() { reset(); }
    function handleSkip() { chimeEnd(); nextPhase(); }

    startBtn.addEventListener('click', handleStart);
    pauseBtn.addEventListener('click', handlePause);
    resetBtn.addEventListener('click', handleReset);
    skipBtn.addEventListener('click', handleSkip);

    fullscreenStartBtn.addEventListener('click', handleStart);
    fullscreenPauseBtn.addEventListener('click', handlePause);
    fullscreenResetBtn.addEventListener('click', handleReset);
    fullscreenSkipBtn.addEventListener('click', handleSkip);

    fullscreenBtn.addEventListener('click', enterFullscreenMode);
    exitFullscreenBtn.addEventListener('click', exitFullscreenMode);

    document.addEventListener('fullscreenchange', () => { if (!document.fullscreenElement && isFullscreenMode) { exitFullscreenMode(); } });
    document.addEventListener('keydown', (e) => { if (e.key === 'Escape' && isFullscreenMode) { exitFullscreenMode(); } });

    [exercisesEl, peopleEl, workSecEl, restSecEl, roundsEl, roundRestSecEl, volEl, beepsChk].forEach(el=>{ el.addEventListener('input', readInputs); });

    function save(){
      const data = { ex: exercisesEl.value, pe: peopleEl.value, w: workSecEl.value, r: restSecEl.value, n: roundsEl.value, rr: roundRestSecEl.value };
      try{ localStorage.setItem('interval_trainer_cfg', JSON.stringify(data)); }catch(e){}
    }
    function load(){
      try{
        const raw = localStorage.getItem('interval_trainer_cfg');
        if(!raw) return; const d = JSON.parse(raw);
        if(d.ex) exercisesEl.value = d.ex; if(d.pe) peopleEl.value = d.pe;
        if(d.w) workSecEl.value = d.w; if(d.r) restSecEl.value = d.r;
        if(d.n) roundsEl.value = d.n; if(d.rr) roundRestSecEl.value = d.rr;
      }catch(e){}
    }

    // Presets
    function loadPresets() { try { const raw = localStorage.getItem('interval_trainer_presets'); state.presets = raw ? JSON.parse(raw) : []; } catch (e) { state.presets = []; } }
    function savePreset(name) {
      const preset = { name, exercises: exercisesEl.value, people: peopleEl.value, workSec: workSecEl.value, restSec: restSecEl.value, rounds: roundsEl.value, roundRestSec: roundRestSecEl.value };
      state.presets.push(preset); localStorage.setItem('interval_trainer_presets', JSON.stringify(state.presets)); renderPresets();
    }
    function applyPreset(preset) { exercisesEl.value=preset.exercises; peopleEl.value=preset.people; workSecEl.value=preset.workSec; restSecEl.value=preset.restSec; roundsEl.value=preset.rounds; roundRestSecEl.value=preset.roundRestSec; readInputs(); setPhase(0); }
    function renderPresets() {
      const list = document.querySelector('#presetList'); list.innerHTML = '';
      if (!state.presets.length) { list.innerHTML = '<div class="muted">Nema spremljenih preseta.</div>'; return; }
      state.presets.forEach((p, i) => {
        const row = document.createElement('div'); row.className = 'row';
        const btn = document.createElement('button'); btn.className = 'btn'; btn.textContent = p.name; btn.addEventListener('click', () => applyPreset(p)); row.appendChild(btn);
        const delBtn = document.createElement('button'); delBtn.className = 'btn red'; delBtn.textContent = '✕'; delBtn.addEventListener('click', () => { state.presets.splice(i, 1); localStorage.setItem('interval_trainer_presets', JSON.stringify(state.presets)); renderPresets(); }); row.appendChild(delBtn);
        list.appendChild(row);
      });
    }
    document.querySelector('#savePresetBtn').addEventListener('click', () => { const name = document.querySelector('#presetName').value.trim(); if (name) { savePreset(name); document.querySelector('#presetName').value = ''; } });

    // init
    load(); loadPresets(); readInputs(); renderPresets(); setPhase(0);
  </script>
</body>
</html>
